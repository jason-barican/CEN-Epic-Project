#Software Engineering Course Project
#Group 3
#Cooper Poole
#Christian Chow Quan 
#Jason Barican
#Jian Gong
#Eloy Fernandes Ballesteros


import tkinter as tk
import sqlite3
from tkinter import messagebox
import Important_Links as IL
import Useful_Links as UL

#global arrays to store account information during runtime

loginUsername = ''
accUsernames = []
accPasswords = []
accFullNames = []
accEmailPrefs = 1
accSMSPrefs = 1
accTAPrefs = 1
accLangPrefs = "English"
PrevWindow = "MainMenu"

#presents menu for user to utilize application functions
class MainMenu(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        #self.controller.geometry("800x800")
        self.controller.title('InCollege beta v0.3.4')

        
        accFile = open("accounts.txt","r+")
        accounts = accFile.readlines()
        self.controller.loadAccounts(accounts)
        
        tk.Label(self, text = "Welcome to InCollege Beta!\n\nINCOLLEGE SUCCESS STORY\nJohn used LinkedIn.\nHe could not get a job.\nJohn then started using InCollege.\nHe got a job.\n\nPlease select an option below.").pack(padx=10, pady=10)
        
        # Create a dropdown menu with the options "General", "Browse InCollege", "Business Solutions", and "Directories"
        menu_var = tk.StringVar()
        menu_var.set("Useful Links")
        options = ["General", "Browse InCollege", "Business Solutions", "Directories"]
        option_menu = tk.OptionMenu(self, menu_var, *options)
        option_menu.pack(padx=10, pady=10)
        option_menu.config(width=25, height =2)

        
        # Create buttons to navigate to different frames based on the selected option
        loginButton = tk.Button(self, text="Login", command=lambda: controller.show_frame("LoginWindow"), width = 25, height = 2)
        loginButton.pack(padx=10, pady=10)
        
        signInButton = tk.Button(self, text="Sign-Up", command=lambda: controller.show_frame("SignUpWindow"), width = 25, height = 2)
        signInButton.pack(padx=10, pady=10)
        
        videoButton = tk.Button(self, text="Play Video", command=lambda: controller.show_frame("VideoWindow"), width = 25, height = 2)
        videoButton.pack(padx=10, pady=10)
        
        findSomeoneButton = tk.Button(self, text="Find Someone", command=lambda: controller.show_frame("FindSomeoneFrame"), width = 25, height = 2)
        findSomeoneButton.pack(padx=10, pady=10)
        
        option_menu['menu'].entryconfig(0, command=lambda: controller.show_frame("GeneralWindow"))
        # Bind the "Browse InCollege", "Business Solutions", and "Directories" options to the "under_construction" function
        option_menu['menu'].entryconfig(1, command=lambda: controller.show_frame("UnderConstruction"))
        option_menu['menu'].entryconfig(2, command=lambda: controller.show_frame("UnderConstruction"))
        option_menu['menu'].entryconfig(3, command=lambda: controller.show_frame("UnderConstruction"))
        
        exitButton = tk.Button(self, text="Exit", command=self.quit, width = 25, height = 2)
        exitButton.pack(padx=10, pady=10)

        # Create the second dropdown menu with the options "Copyright Notice", "About", "Accessibility", "User Agreement", "Privacy Policy", "Cookie Policy", "Copyright Policy", "Brand Policy", "Guest Controls", and "Languages"
        menu_var2 = tk.StringVar()
        menu_var2.set("InCollege Important Links")
        options2 = ["Copyright Notice",
                    "About",
                    "Accessibility",
                    "User Agreement",
                    "Privacy Policy",
                    "Cookie Policy",
                    "Copyright Policy",
                    "Brand Policy",
                    "Languages"]
        option_menu2 = tk.OptionMenu(self, menu_var2, *options2)
        option_menu2.pack(padx=10, pady=10)
        option_menu2['menu'].entryconfig(0, command=lambda: controller.show_frame("CopyrightNoticeFrame"))
        option_menu2['menu'].entryconfig(1, command=lambda: controller.show_frame("InCollegeAboutFrame"))
        option_menu2['menu'].entryconfig(2, command=lambda: controller.show_frame("AccessibilityNoticeFrame"))
        option_menu2['menu'].entryconfig(3, command=lambda: controller.show_frame("UserAgreementFrame"))
        option_menu2['menu'].entryconfig(4, command=lambda: controller.show_frame("PrivacyPolicyFrame"))
        option_menu2['menu'].entryconfig(5, command=lambda: controller.show_frame("CookiePolicyFrame"))
        option_menu2['menu'].entryconfig(6, command=lambda: controller.show_frame("CopyrightPolicyFrame"))
        option_menu2['menu'].entryconfig(7, command=lambda: controller.show_frame("BrandPolicyFrame"))
        option_menu2['menu'].entryconfig(9, command=lambda: controller.show_frame("LanguageFrame"))
        option_menu2.config(width=25, height =2)


class GuestControlsFrame(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller

    # Create a label for the frame
    label = tk.Label(self, text="Guest Controls")
    label.pack(pady=10)

    # Create the InCollege Email checkbox
    email_var = tk.BooleanVar()
    email_checkbutton = tk.Checkbutton(self, text="InCollege Email", variable=email_var)
    email_checkbutton.pack()

    # Create the SMS checkbox
    sms_var = tk.BooleanVar()
    sms_checkbutton = tk.Checkbutton(self, text="SMS", variable=sms_var)
    sms_checkbutton.pack()

    # Create the Targeted Advertising checkbox
    targeting_var = tk.BooleanVar()
    targeting_checkbutton = tk.Checkbutton(self, text="Targeted Advertising", variable=targeting_var)
    targeting_checkbutton.pack()

    # Create a button to go back to the previous frame
    back_button = tk.Button(self, text="Back", command=lambda: controller.show_frame("MainMenu"))
    back_button.pack(pady=10)


class LanguageFrame(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller
    self.conn = sqlite3.connect('database.db')  
    self.cursor = self.conn.cursor()

    # Create a label
    label = tk.Label(self, text="Please select your preferred language:")
    label.pack(pady=10)

    # Create a StringVar to hold the selected language
    self.language_var = tk.StringVar()

    self.bind("<<ShowFrame>>", self.on_show_frame)
    # Create two checkboxes for English and Spanish, and make them mutually exclusive
    self.english_checkbox = tk.Checkbutton(self, text="English", variable=self.language_var, onvalue="English", offvalue="")
    self.spanish_checkbox = tk.Checkbutton(self, text="Spanish", variable=self.language_var, onvalue="Spanish", offvalue="")
    self.english_checkbox.select()
    self.english_checkbox.pack(pady=5)
    self.spanish_checkbox.pack(pady=5)
    # Create a button to save the selected language and return to the previous frame
    save_button = tk.Button(self, text="Save and Return", command=self.save_language)
    save_button.pack(pady=10)

  def on_show_frame(self, event):
    selected_language = self.language_var.get() 
    get_lang_pref_query = "SELECT LANG_PREF FROM USER_DATA WHERE USERNAME = '"+ loginUsername +"'"

    print(get_lang_pref_query)
    self.cursor.execute(get_lang_pref_query)
    selected_language = self.cursor.fetchone()
    sel_lang = selected_language[0]
 
    if sel_lang == "English":
      self.english_checkbox.select()
    elif sel_lang == "Spanish":
      self.spanish_checkbox.select()


  def save_language(self):
    global loginUsername
    # Get the selected language from the StringVar and save it
    update_lang_pref_query = "UPDATE USER_DATA SET LANG_PREF = 'English' WHERE USERNAME = '"+ loginUsername +"'"
    if self.language_var.get() == "English":
      update_lang_pref_query = "UPDATE USER_DATA SET LANG_PREF = 'English' WHERE USERNAME = '"+ loginUsername +"'"
    elif self.language_var.get() == "Spanish":
      update_lang_pref_query = "UPDATE USER_DATA SET LANG_PREF = 'Spanish' WHERE USERNAME = '"+ loginUsername +"'"
    self.cursor.execute(update_lang_pref_query)
    self.conn.commit()


    # Return to the previous frame
    self.controller.show_frame(PrevWindow)




class GeneralWindow(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        
        tk.Label(self, text = "General", font = ("Arial", 14)).pack(pady = 10)
        
        signUpButton = tk.Button(self, text="Sign Up", command=lambda: controller.show_frame("SignUpWindow"))
        signUpButton.pack(pady = 10)
        
        helpCenterButton = tk.Button(self, text="Help Center", command=lambda: controller.show_frame("HelpCenterFrame"))
        helpCenterButton.pack(pady = 10)
        
        aboutButton = tk.Button(self, text="About", command=lambda: controller.show_frame("AboutFrame"))
        aboutButton.pack(pady = 10)
        
        pressButton = tk.Button(self, text="Press", command=lambda: controller.show_frame("PressFrame"))
        pressButton.pack(pady = 10)
        
        blogButton = tk.Button(self, text="Blog", command=lambda: controller.show_frame("UnderConstruction"))
        blogButton.pack(pady = 10)
        
        careersButton = tk.Button(self, text="Careers", command=lambda: controller.show_frame("UnderConstruction"))
        careersButton.pack(pady = 10)
        
        developersButton = tk.Button(self, text="Developers", command=lambda: controller.show_frame("UnderConstruction"))
        developersButton.pack(pady = 10)
        
        backButton = tk.Button(self, text="Back", command=lambda: controller.show_frame("MainMenu"))
        backButton.pack(pady = 10)



class LoginWindow(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller

    tk.Label(self, text = "Please enter username and password.").pack(padx=10, pady=10)
    self.loggedIn = False

    usernameLabel = tk.Label(self, text = "Username:")
    usernameLabel.pack(padx=10, pady=10)
    self.usernameEntry = tk.Entry(self, bd = 5)
    self.usernameEntry.pack(padx=10, pady=10)

    passwordLabel = tk.Label(self, text = "Password:")
    passwordLabel.pack(padx=10, pady=10)
    self.passwordEntry = tk.Entry(self, bd = 5)
    self.passwordEntry.pack(padx=10, pady=10)

    buttonframe = tk.Frame(self)
    buttonframe.pack()
    enterButton = tk.Button(buttonframe, text = "Enter", 
                            command = lambda: self.login())
    enterButton.pack(padx = 10, pady = 10)

    backButton = tk.Button(buttonframe, text = "Back", 
                          command = lambda: controller.show_frame("MainMenu"))
    backButton.pack(padx=10, pady=10)



  def login(self):
    global loginUsername
    loginUsername = self.usernameEntry.get()
    loginPassword = self.passwordEntry.get()

    self.database = sqlite3.connect('database.db')  
    self.databaseCursor = self.database.cursor()

    self.databaseCursor.execute("SELECT * from USER_DATA")
    accounts = self.databaseCursor.fetchall()

    print(accounts)

    for i in range(0, len(accounts)):
      if loginUsername in accounts[i]:
        if loginPassword in accounts[i]:
          
          self.loggedIn = True
          messagebox.showinfo("Logged In", "You have successfully logged in.")
          self.controller.show_frame("ApplicationWindow")

    if self.loggedIn == False:
      messagebox.showerror("Error", "Incorrect username/password. Please try again.")
              
    
class SignUpWindow(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller

    #opens database
    self.conn = sqlite3.connect('database.db')  
    self.cursor = self.conn.cursor()
    
    #username entry
    tk.Label(self, text="Create Username:").pack(padx=10, pady=10)
    self.newUsernameEntry = tk.Entry(self,bd = 5)
    self.newUsernameEntry.pack(padx=10, pady=10)

    #password entry
    tk.Label(self,text= "Create Password:").pack(padx=10, pady=10)
    self.newPasswordEntry = tk.Entry(self,bd = 5)
    self.newPasswordEntry.pack(padx=10, pady=10)

    #full name entry
    tk.Label(self,text= "Enter your first and last name:").pack(padx=10, pady=10)
    self.fullNameEntry = tk.Entry(self,bd = 5)
    self.fullNameEntry.pack(padx=10, pady=10)

    self.enterButton = tk.Button(self, text = "Enter", 
                          command = lambda: self.checkIfValid())
    self.enterButton.pack(padx = 10, pady = 10)
    
    self.backButton = tk.Button(self, text = "Back", 
                        command = lambda: controller.show_frame("MainMenu"))
    self.backButton.pack(padx=10, pady=10)
        

  def checkIfValid(self):

    count = 0
    self.cursor.execute('''SELECT * from USER_DATA''')
    database = self.cursor.fetchall()
    
    usernameValid = False
    passwordValid = False
    fullNameValid = False

    count += len(database)
    
    if count >= 5:
      tk.Label(self, text="All permitted accounts have been created. Please come back later.").pack(padx=10, pady=10)
    else:
      self.newUsername = self.newUsernameEntry.get().replace(" ","")
      
      if len(database) != 0:
        self.cursor.execute("SELECT USERNAME from USER_DATA")
        usernames = self.cursor.fetchall()

        for i in range(0, len(usernames)):

          #ensuring username is unique
          if self.newUsername in usernames[i] or self.newUsername == "":
            messagebox.showerror("Error", "Invalid Entry/Account username already in use. Please try again.")
            self.newUsernameEntry.delete(0, 'end')
          else:
             usernameValid = True

      elif self.newUsername == "":
        messagebox.showerror("Error", "Invalid Entry/Account username already in use. Please try again.")
      
      elif len(database) == 0:
         usernameValid = True
  
    
    hasDigit = False
    hasNonAlphaNumeric = False
    
    self.newPassword = self.newPasswordEntry.get().replace(" ","")

    #validation check for length and presence of upercase, special, and numeric character.
    if len(self.newPassword) >= 8 and len(self.newPassword) <= 12 and self.newPassword.lower() != self.newPassword:
      for char in self.newPassword:
        if char.isdigit():
          hasDigit = True
        if not char.isalpha():
          hasNonAlphaNumeric = True
    if hasDigit is not True and hasNonAlphaNumeric is not True:
      messagebox.showerror("Error", "Invalid Password. Try a better password.")
      self.newPasswordEntry.delete(0, 'end')
    else:
      passwordValid = True

 
    self.name = self.fullNameEntry.get()
    nameCount = self.name.split()

    if len(nameCount) != 2:
      messagebox.showerror("Error", "Invalid format, Two names not found. Please try again.")
      self.fullNameEntry.delete(0, 'end')

    else:
      fullNameValid = True
      self.firstName = nameCount[0]
      self.lastName = nameCount[1]

    if usernameValid is True and passwordValid is True and fullNameValid is True:
      data_insert_query = ('''INSERT INTO USER_DATA(
                          USERNAME, PASSWORD, FIRSTNAME, LASTNAME, EMAIL_PREF, SMS_PREF, TA_PREF, LANG_PREF) VALUES
                          (?, ?, ?, ?, ?, ?, ?, ?)
                          ''')
    
    
      #executed through tuples since insert query cant read from variable
      data_insert_tuple = (self.newUsername, self.newPassword, self.firstName, self.lastName, accEmailPrefs, accSMSPrefs, accTAPrefs, accLangPrefs)

      self.cursor.execute(data_insert_query, data_insert_tuple)
      self.conn.commit()
      
      messagebox.showinfo("Account Created", "You have successfully created a new account.")

      self.newUsernameEntry.delete(0, 'end')
      self.newPasswordEntry.delete(0, 'end')
      self.fullNameEntry.delete(0, 'end')
      self.controller.show_frame("MainMenu")

      usernameValid = False
      passwordValid = False
      fullNameValid = False


class VideoWindow(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller

    tk.Label(self, text = "Video is now playing").pack(padx=10, pady=10)
    backButton = tk.Button(self, text = "Back", 
                          command = lambda: controller.show_frame("MainMenu"))
    backButton.pack(padx=10, pady=10)


class ApplicationWindow(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller    

    tk.Label(self, text = "You have successfully logged in!\nPlease select an option.").pack(padx=10, pady=10) 

    menu_var = tk.StringVar()
    menu_var.set("Useful Links")
    options = ["General", "Browse InCollege", "Business Solutions", "Directories"]
    option_menu = tk.OptionMenu(self, menu_var, *options)
    option_menu.pack(padx = 10, pady = 10)
    self.bind("<<ShowFrame>>", self.on_show_frame)

    option_menu['menu'].entryconfig(0, command=lambda: controller.show_frame("GeneralWindow"))
    # Bind the "Browse InCollege", "Business Solutions", and "Directories" options to the "under_construction" function
    option_menu['menu'].entryconfig(1, command=lambda: controller.show_frame("UnderConstruction"))
    option_menu['menu'].entryconfig(2, command=lambda: controller.show_frame("UnderConstruction"))
    option_menu['menu'].entryconfig(3, command=lambda: controller.show_frame("UnderConstruction"))

    jobSearchButton = tk.Button(self, text = "Job/Internship Search", command = lambda: controller.show_frame("JobSearchFrame"))
    jobSearchButton.pack(padx = 10, pady = 10)

    findSomeoneButton = tk.Button(self, text = "Find Someone", command = lambda: controller.show_frame("FindSomeoneFrame"))
    findSomeoneButton.pack(padx = 10, pady = 10)

    learnSkillButton = tk.Button(self, text = "Learn a new skill", command = lambda: controller.show_frame("LearnSkillWindow"))
    learnSkillButton.pack(padx = 10, pady = 10)

    postJobButton = tk.Button(self, text = "Post a new job", command = lambda: controller.show_frame("AddJobFrame"))
    postJobButton.pack(padx = 10, pady = 10)

    postJobButton = tk.Button(self, text = "Add friends", command = lambda: controller.show_frame("FriendFrame"))
    postJobButton.pack(padx = 10, pady = 10)

    exitButton = tk.Button(self, text = "Exit", command = self.quit)
    exitButton.pack(padx = 10, pady = 10)

    backButton = tk.Button(self, text="Back to Main Menu", command=lambda: controller.show_frame("MainMenu"))
    backButton.pack(padx = 10, pady = 10)

# Create the second dropdown menu with the options "Copyright Notice", "About", "Accessibility", "User Agreement", "Privacy Policy", "Cookie Policy", "Copyright Policy", "Brand Policy", "Guest Controls", and "Languages"
    menu_var2 = tk.StringVar()
    menu_var2.set("InCollege Important Links")
    options2 = ["Copyright Notice",
                "About",
                "Accessibility",
                "User Agreement",
                "Privacy Policy",
                "Cookie Policy",
                "Copyright Policy",
                "Brand Policy",
                "Languages"]
    option_menu2 = tk.OptionMenu(self, menu_var2, *options2)
    option_menu2.pack(padx = 10, pady = 10)
    option_menu2['menu'].entryconfig(0, command=lambda: controller.show_frame("CopyrightNoticeFrame"))
    option_menu2['menu'].entryconfig(1, command=lambda: controller.show_frame("InCollegeAboutFrame"))
    option_menu2['menu'].entryconfig(2, command=lambda: controller.show_frame("AccessibilityNoticeFrame"))
    option_menu2['menu'].entryconfig(3, command=lambda: controller.show_frame("UserAgreementFrame"))
    option_menu2['menu'].entryconfig(4, command=lambda: controller.show_frame("PrivacyPolicyFrame"))
    option_menu2['menu'].entryconfig(5, command=lambda: controller.show_frame("CookiePolicyFrame"))
    option_menu2['menu'].entryconfig(6, command=lambda: controller.show_frame("CopyrightPolicyFrame"))
    option_menu2['menu'].entryconfig(7, command=lambda: controller.show_frame("BrandPolicyFrame"))
    option_menu2['menu'].entryconfig(9, command=lambda: controller.show_frame("LanguageFrame"))

  def on_show_frame(self, event):
    PrevWindow = "ApplicationWindow"

class LearnSkillWindow(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller

    tk.Label(self, text = "Please select a skill to learn.").pack(padx=10, pady=10) 


    skill1Button = tk.Button(self, text = "Skill 1",
                            command = lambda: controller.show_frame("UnderConstruction"))
    skill1Button.pack(padx = 10, pady = 10)

    skill2Button = tk.Button(self, text = "Skill 2",
                                  command = lambda: controller.show_frame("UnderConstruction"))
    skill2Button.pack(padx = 10, pady = 10)

    skill3Button = tk.Button(self, text = "Skill 3",
                            command = lambda: controller.show_frame("UnderConstruction"))
    skill3Button.pack(padx = 10, pady = 10)

    skill4Button = tk.Button(self, text = "Skill 4",
                            command = lambda: controller.show_frame("UnderConstruction"))
    skill4Button.pack(padx = 10, pady = 10)

    skill5Button = tk.Button(self, text = "Skill 5",
                            command = lambda: controller.show_frame("UnderConstruction"))
    skill5Button.pack(padx = 10, pady = 10)

    backButton = tk.Button(self, text="Back", command=lambda: controller.show_frame("ApplicationWindow"))
    backButton.pack(padx = 10, pady = 10)

    exitButton = tk.Button(self, text = "Exit", command = self.quit)
    exitButton.pack(padx = 10, pady = 10)




    
class UnderConstruction(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller  

    tk.Label(self, text="Under Construction.").pack(padx=10, pady=10)

    backButton = tk.Button(self, text = "Back", 
                          command = lambda: controller.show_frame("MainMenu"))
    backButton.pack(padx=10, pady=10)

          


class FindSomeoneFrame(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller 
    self.create_widgets()

  def create_widgets(self):
      self.name_label = tk.Label(self, text="Enter full name of person:")
      self.name_entry = tk.Entry(self)
      self.name_label.pack(padx=10, pady=10)
      self.name_entry.pack(padx=10, pady=10)

      self.search_button = tk.Button(self, text="Search", command=self.search)
      self.search_button.pack(padx=10, pady=10)

      backButton = tk.Button(self, text = "Back", 
                            command = lambda: self.controller.show_frame("MainMenu"))
      backButton.pack(padx=10, pady=10)

  def search(self):
      searched_name = self.name_entry.get()

      if searched_name not in accFullNames:
          result_text = "They are not a part of the InCollege system yet."
      else:
          result_text = f"{searched_name} is part of the InCollege system. Login or sign up to join them!"
      result_label = tk.Label(self, text=result_text)
      result_label.pack(padx=10, pady=10)
      
class JobSearchFrame(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller

    tk.Label(self, text="Welcome to Job/Internship Search!\nPlease select an option below.").pack(padx=10, pady=10)

    addJobButton = tk.Button(self, text = "Add Job",
                            command = lambda: controller.show_frame("AddJobFrame"))
    addJobButton.pack(padx = 10, pady = 10)

    backButton = tk.Button(self, text = "Back", 
                          command = lambda: controller.show_frame("ApplicationWindow"))
    backButton.pack(padx=10, pady=10)

"""
class FriendFrame(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller
    # Create Scrollbar widget and Canvas widget
    scrollbar = tk.Scrollbar(self)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    self.canvas = tk.Canvas(self, yscrollcommand=scrollbar.set)
    self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.config(command=self.canvas.yview)
    # Create a Frame widget to contain all the elements and buttons
    self.frame = tk.Frame(self.canvas)
    self.canvas.create_window((0, 0), window=self.frame, anchor='nw')
    # Read the specified elements from the file
    self.elements = self.read_file('accounts.txt', '"start"', '"end"')
    # Display the elements and buttons in the Frame widget
    self.add_elements()
    # Allow the Canvas widget to automatically adjust its size
    self.frame.update_idletasks()
    self.canvas.config(scrollregion=self.canvas.bbox('all'))
  def read_file(self, filename, start_elem, end_elem):
    elements = []
    with open(filename, 'r') as f:
        content = f.read()
        start_index = content.index(start_elem) + len(start_elem)
        end_index = len(content)  # Assume end of file is end index
        if end_elem in content[start_index:]:
            end_index = content.index(end_elem, start_index)
            # Split the content between start_elem and end_elem into elements
            content_between = content[start_index:end_index]
            elements = [e.strip() for e in content_between.split("\"")]
        else:
            end_index = len(content)  # Assume end of file is end index
    return elements
  
  def add_elements(self):
    if not self.elements:
        # Display "No new request" if there are no elements
        label = tk.Label(self.frame, text="No new request", width=50)
        label.grid(row=0, column=0, padx=5, pady=5)
    else:
        # Add elements and buttons to the Frame widget
        for i, element in enumerate(self.elements):
            label = tk.Label(self.frame, text=element, width=50)
            label.grid(row=i, column=0, padx=5, pady=5)
            button1 = tk.Button(self.frame, text='reject', command=lambda element=element: self.delete_element(element))
            button1.grid(row=i, column=1, padx=5, pady=5)
            button2 = tk.Button(self.frame, text='accept', command=lambda element=element: self.move_element(element))
            button2.grid(row=i, column=2, padx=5, pady=5)
    backButton = tk.Button(self, text = "Back", command = lambda: self.controller.show_frame("ApplicationWindow"))
    backButton.pack(padx=5, pady=5)
  def delete_element(self, element):
    # Read the file and remove the specified element
    with open('accounts.txt', 'r') as f:
        lines = f.readlines()
    with open('accounts.txt', 'w') as f:
        for line in lines:
            if element not in line:
                f.write(line)
            else:
                # Remove the specified element from the line
                line = line.replace(element, "")
                line = line.replace('""', '"')
                f.write(line)
    self.update_frame()
  def move_element(self, element):
# Read the contents of the file into a variable
    with open('accounts.txt', 'r') as f:
        content = f.read()
    # Find the index of the "end" tag
    end_index = content.find('"end"')
    # Delete the element if it exists in the file
    if element in content:
        content = content.replace(element, '')
    # Write the updated content back to the file
    with open('accounts.txt', 'w') as f:
        content = content.replace('""', '"')
        f.write(content)
    # Update the Frame widget
    self.update_frame()
  def update_frame(self):
    # Reload the elements
    self.elements = self.read_file('accounts.txt', '"start"', '"end"')
    # Update the Frame widget
    self.frame.destroy()
    self.frame = tk.Frame(self.canvas)
    self.canvas.create_window((0, 0), window=self.frame, anchor='nw')
    self.add_elements()
    # Allow the Canvas widget to automatically adjust its size
    self.frame.update_idletasks()
    self.canvas.config(scrollregion=self.canvas.bbox('all'))
"""


class AddJobFrame(tk.Frame):
  def __init__(self, parent, controller):
    tk.Frame.__init__(self, parent)
    self.controller = controller
    self.create_widgets()

  def create_widgets(self):
      self.title_label = tk.Label(self, text="Enter title:")
      self.title_entry = tk.Entry(self)
      self.title_label.grid(row=0, column=0, padx=5, pady=5)
      self.title_entry.grid(row=0, column=1, padx=5, pady=5)

      self.description_label = tk.Label(self, text="Enter description:")
      self.description_entry = tk.Entry(self)
      self.description_label.grid(row=1, column=0, padx=5, pady=5)
      self.description_entry.grid(row=1, column=1, padx=5, pady=5)

      self.employer_label = tk.Label(self, text="Enter employer:")
      self.employer_entry = tk.Entry(self)
      self.employer_label.grid(row=2, column=0, padx=5, pady=5)
      self.employer_entry.grid(row=2, column=1, padx=5, pady=5)

      self.location_label = tk.Label(self, text="Enter location:")
      self.location_entry = tk.Entry(self)
      self.location_label.grid(row=3, column=0, padx=5, pady=5)
      self.location_entry.grid(row=3, column=1, padx=5, pady=5)

      self.salary_label = tk.Label(self, text="Enter salary:")
      self.salary_entry = tk.Entry(self)
      self.salary_label.grid(row=4, column=0, padx=5, pady=5)
      self.salary_entry.grid(row=4, column=1, padx=5, pady=5)

      self.post_button = tk.Button(self, text="Post job", command=self.post_job)
      self.post_button.grid(row=5, column=0, columnspan=2, padx=5, pady=5)

      self.back_button = tk.Button(self, text="Back", command=lambda: self.controller.show_frame("ApplicationWindow"))
      self.back_button.grid(row=6, column=0, columnspan=2, padx=5, pady=5)

  def post_job(self):
      jobFile = open("jobs.txt","r+")
      global loginUsername
      jobs = jobFile.readlines()
      count = 0
      for job in jobs:
        count += 1

      #checking if amount of accounts has exceeded maximum
      if count >= 5:
        result_text = "All permitted jobs have been created, please come back later"
      else:
        title = self.title_entry.get()
        description = self.description_entry.get()
        employer = self.employer_entry.get()
        location = self.location_entry.get()
        salary = self.salary_entry.get()
        jobFile.write(title + " " + description + " " + employer + " " + location + " " + salary + " " + loginUsername +"\n")
        result_text = "New job posted!"

      result_label = tk.Label(self, text=result_text)
      result_label.grid(row=7, column=0, columnspan=2, padx=5, pady=5)


class MainWindow(tk.Tk):
  def __init__(self, *args, **kwargs):
    tk.Tk.__init__(self, *args, **kwargs)

    mainframe = tk.Frame()
    self.windowNum = 0
    mainframe.pack(padx = 5, pady = 5,)# fill = 'both', expand = 1)
    self.framelist = {}                 #dictionary for different pages

    for F in (MainMenu, LoginWindow, SignUpWindow,
              VideoWindow, ApplicationWindow, LearnSkillWindow,
              FindSomeoneFrame, JobSearchFrame, AddJobFrame, IL.CopyrightNoticeFrame,
              IL.InCollegeAboutFrame, IL.AccessibilityNoticeFrame, IL.UserAgreementFrame,
              IL.PrivacyPolicyFrame, IL.CookiePolicyFrame, IL.CopyrightPolicyFrame,
              IL.BrandPolicyFrame, GuestControlsFrame, LanguageFrame,
              GeneralWindow, UL.HelpCenterFrame, UL.AboutFrame, 
              UL.PressFrame, UnderConstruction):

      frame_name = F.__name__
      frame = F(parent = mainframe, controller = self)
      frame.grid(row = 0, column = 0, sticky = 'nsew')
      self.framelist[frame_name] = frame

    self.show_frame("MainMenu")

    #creation of sqlite database
    database = sqlite3.connect('database.db')
    table_create_query = '''CREATE TABLE IF NOT EXISTS USER_DATA(
                    USERNAME TEXT, 
                    PASSWORD TEXT, 
                    FIRSTNAME TEXT, 
                    LASTNAME TEXT,
                    EMAIL_PREF INT,
                    SMS_PREF INT, 
                    TA_PREF INT,
                    LANG_PREF TEXT 
    )'''

    database.execute(table_create_query)
    

  def show_frame(self, frame_name):
    frame = self.framelist[frame_name]
    frame.event_generate("<<ShowFrame>>")
    frame.tkraise()

  def loadAccounts(self, accounts):
    accUsernames.clear()
    accPasswords.clear()
    accFullNames.clear()

    for acc in accounts:
      accInfo = acc.split()
      if len(accInfo) > 7:
        accUsernames.append(accInfo[0])
        accPasswords.append(accInfo[1])
        accFullNames.append(accInfo[2] + " " + accInfo[3])

  
if __name__ == '__main__':
  window = MainWindow()
  window.mainloop()
